# spring_lab2

Роботу виконала студентка групи ІО-03 Герасименко Вікторія

Варіант 14:

Тема: Система замовлення їжі
Сутності: Меню, елементи меню, замовлення
Актори: Користувач, Адміністратор
Сценарії використання: 
Адміністратор: Створення/Видалення/Перегляд елементів меню, Перегляд замовлень, Оброблення замовлення
Користувач: Перегляд меню, створення замовлення, додавання елементів меню у замовлення, відправка замовлення

План

Буде створено репозиторій користувача з різним рівнем доступу до інформації про систему замовленн їжі:
Адміністратор може створювати/видаляти та переглядати елементи меню, переглядати та обробляти замовлення
Користувач може переглядати меню, створювати та відправляти замовлення, додаючи елемет меню в замовлення.

Контрольні питання:

1. Поясніть значення наступних термінів:
Inversion of Control (IoC);
IoC container;
Dependency Injection (DI);
Dependency inversion principle.

Відповідь: 
IoC (інверсія контролю) - це концепція, яка переносить відповідальність за виконання дій із коду програми на фреймворк, тобто код не викликає бібліотеку і просе її допомогти, а навпаки фреймворк сам з'ясовує, що потрібно компонентам і надає їм це.
IoC container - це частина Spring або якась програма, яка дозволить вам спростити та автоматизувати написання коду з використанням IoC на стільки, наскільки це можливо. У Spring об’єкти, які утворюють основу вашої програми та якими керує контейнер Spring IoC, називаються компонентами. Компонент — це об’єкт, який створюється, збирається та іншим чином керується контейнером Spring IoC.
Dependency Injection (ін'єкція залежності) — це шаблон, який ми можемо використовувати для реалізації IoC, де інвертований елемент керування встановлює залежності об’єкта.
Dependency inversion principle - один із найвідоміших сьогодні принципів проектування, який лежить в основі популярних технік впровадження залежностей (Dependency Injection). Модулі верхнього рівня не повинні залежати від модулів нижнього рівня. І ті, й інші повинні залежати від абстракцій. Абстракції не повинні залежати від деталей. Деталі мають залежати від абстракцій.

2. В чому полягає різниця між анотаціями @Component та @Bean? Опишіть переваги та недоліки створення бінів за допомогою цих анотацій.

Відповідь: 
@Component і @Bean роблять дві абсолютно різні речі, і їх не слід плутати. @Component використовується для автоматичного виявлення та автоматичного налаштування компонентів за допомогою сканування шляху до класів. Існує неявне відображення один-до-одного між анотованим класом і компонентом (тобто один компонент на клас). @Bean використовується для явного оголошення одного bean-компонента замість того, щоб дозволити Spring робити це автоматично, як описано вище. Він відокремлює оголошення bean-компонента від визначення класу та дозволяє створювати та налаштовувати bean-компоненти саме так, як ви виберете.
@Component бажано для сканування компонентів і автоматичного підключення, а @Bean якщо ви хочете зв’язати компоненти зі сторонніх бібліотек (у вас немає вихідного коду, тому ви не можете анотувати його класи за допомогою @Component), тому автоматичне налаштування неможливе.

3. Чому слід уникати ін’єкцій залежностей напряму у поле біна?

Відповідь: 
Ін’єкцій залежностей напряму у поле біна — це, ймовірно, найпростіша (але ризикована) форма впровадження залежностей. Проблеми:
Ви не можете створити незмінні об’єкти, як це можна зробити за допомогою ін’єкції конструктора
Ваші класи тісно пов’язані з контейнером DI і не можуть використовуватися поза ним
Ваші класи не можуть бути створені (наприклад, у модульних тестах) без рефлексії. Вам потрібен контейнер DI, щоб створити їх, що робить ваші тести більш схожими на інтеграційні тести
Ваші реальні залежності приховані ззовні та не відображаються у вашому інтерфейсі (ані конструкторах, ані методах)

4. В яких випадках краще використовувати ін’єкції залежностей за допомогою конструкторів, а в яких за допомогою сетерів?

Відповідь: 
Тільки сетери можна використати для поступового вровадження залежностей, тобто тоді коли треба і не буде проблеми при циркулярних залежностях. Можна легко змінити значення шляхом ін’єкції сеттера. Він не завжди створює новий екземпляр компонента, як конструктор. Отже, ін’єкція сетера є гнучкою, ніж ін’єкція конструктора. В усіх інших випадках конструктор є кращим варіантом.

5. В яких випадках краще використовувати біни типу singleton, а в яких prototype?

Відповідь: 
Singleton (Default): лише один екземпляр буде створено для одного визначення bean-компонента на контейнер Spring IoC, і той самий об’єкт буде спільно використаний для кожного запиту, зробленого для цього bean-компонента. Prototype: новий екземпляр буде створено для визначення окремого bean-компонента кожного разу, коли буде зроблено запит для цього bean-компонента.

6. Чи можливе у Spring Framework створення циркулярних залежностей при ін’єкціях?

Відповідь: 
Циклічна залежність у Spring виникає, коли два або більше bean-компонентів потребують екземплярів один одного через ін’єкції залежностей конструктора. Наприклад: існує ClassA, якому потрібен екземпляр ClassB через ін’єкцію конструктора, а для ClassB потрібен екземпляр класу A через ін’єкцію конструктора.
З циклічною залежністю Spring не може вирішити, який з bean-компонентів слід створити першим, оскільки вони залежать один від одного. У цих випадках Spring викличе BeanCurrentlyInCreationException під час завантаження контексту.
Якщо ми використовуємо інші типи ін’єкцій, у нас не повинно виникнути цієї проблеми, оскільки залежності будуть ін’єктовані, коли вони потрібні, а не під час завантаження контексту.

7. Чи може бути в одному проекті кілька класів з реалізацією якогось інтерфейсу, якщо цей інтерфейс використовується для ін’єкції залежностей?

Відповідь: 
Може, але тоді треба допомогти Spring розрізнити різні реалізації одного інтерфейсу. Для цього можна використати анотацію @Qualifier (тут в дужка дреба дати назву), або заавтовайрить список (List) типу інтерфейса і він зробить ін'єкцію всіх реалізацій. Але ж який порядок буде у списку? - Для того, щоб знати явно, треба прописати @Order з числом, або @Primary, яка надає найвищий пріоритет.
@Autowired private Map<String, StringCallable> map;
Spring автоматично підставить не тільки самі біни, а й імена бінів як ключі. Це може бути ефективно використано, наприклад, у патерні "стратегія".

8. Чи може бін мати кілька методів, помічених анотацією @Autowired?

Відповідь: Так

9. Чи може бін мати кілька конструкторів, помічених анотацією @Autowired?

Відповідь: Тільки один конструктор може мати анотацію @Autowired.
